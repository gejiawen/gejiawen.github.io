

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="gejiawen">
    
    <meta name="description" content="英文原文： Data-binding Revolutions with Object.observe() （需翻墙）
参考

引言一场变革即将到来。Javascript中的一项新特性将会颠覆之前你对于数据绑定的所有认识。它也将改变你所使用的MVC库观察模型中发生的修改以及更新的实现方式。你会看到，那">
    
    

    
    <link rel="alternative" href="atom.xml" title="蛋糕仙人" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Object.observe()带来的数据绑定变革 | 蛋糕仙人 · 技术人需要危机感</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script>
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <meta name="baidu-site-verification" content="SzJ3MGdmeo" />


    <meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />


    <!--<meta name="baidu-site-verification" content="SzJ3MGdmeo" />-->
    <!--<meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />-->

</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://blog.gejiawen.com" title="蛋糕仙人">蛋糕仙人</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a class="max-width max-w300" title="技术人需要危机感" href="/feelings">技术人需要危机感</a>
                    </li>
                </ul>
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index">
                        <a href="/" target="">首页</a>
                    </li>
                    
                    <li id="nav-archives">
                        <a href="/archives" target="">归档</a>
                    </li>
                    
                    <li id="nav-categories">
                        <a href="/categories" target="">分类</a>
                    </li>
                    
                    <li id="nav-tags">
                        <a href="/tags" target="">标签</a>
                    </li>
                    
                    <li id="nav-pick">
                        <a href="http://book.gejiawen.com/fucking-days-to-be-a-coder" target="_blank">拾遗</a>
                    </li>
                    
                    <li id="nav-about">
                        <a href="/about" target="">关于</a>
                    </li>
                    

                    <li id="nav-github"><a href="https://github.com/gejiawen" target="_blank">GitHub</a></li>
                    <!--<li id="nav-rss"><a href="/atom.xml" target="_blank">Rss</a></li>-->
                    <li id="nav-search"><input type="text" id="search" placeholder="search" /></li>
                </ul>
            </div>
        </div>
    </nav>

    <script>
    var bgRoot = "http://7xkwt1.com1.z0.glb.clouddn.com/background-";
    var bgLength = "74";
    var bgRandom = false;
    var bgImage = "http://7xkwt1.com1.z0.glb.clouddn.com/background-64.jpg";

    $(function() {
        // page-id...
        var pageId = "2014/10/30/intro-for-observe-and-data-binding/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";

        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>Object.observe()带来的数据绑定变革</h1>

        <div class="time-info">
            
<span class="article-tags">
    
    Tags: <a href="/tags/转载/">转载</a>&nbsp;<a href="/tags/js/">js</a>&nbsp;<a href="/tags/翻译/">翻译</a>&nbsp;<a href="/tags/es6/">es6</a>&nbsp;
</span>



<span class="article-categories">
    Category:
    <a class="article-category-link" href="/categories/JAVASCRIPT/">JAVASCRIPT</a>
</span>


        </div>
        <div class="time-info">
            发表: <time datetime="2014-10-30T07:48:29.000Z"
                       itemprop="datePublished">2014-10-30 15:48:29</time>
            
            更新: <time datetime="2017-01-15T17:16:24.000Z"
                       itemprop="dateModified">2017-01-16 01:16:24</time>
            
        </div>

        <div class="post-body-inner">
            
                <div id="toc" class="toc-article well">
                    <strong class="toc-title">大纲</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#我们要需要观察什么？"><span class="toc-number">2.</span> <span class="toc-text">我们要需要观察什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据绑定的重要性"><span class="toc-number">3.</span> <span class="toc-text">数据绑定的重要性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#现在使用的数据绑定方案是什么样子的"><span class="toc-number">4.</span> <span class="toc-text">现在使用的数据绑定方案是什么样子的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#脏值检查"><span class="toc-number">4.1.</span> <span class="toc-text">脏值检查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍Object-observe"><span class="toc-number">5.</span> <span class="toc-text">介绍Object.observe()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-observe-和Object-unobserve"><span class="toc-number">5.1.</span> <span class="toc-text">Object.observe()和Object.unobserve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指定感兴趣的变化"><span class="toc-number">5.2.</span> <span class="toc-text">指定感兴趣的变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通知"><span class="toc-number">6.</span> <span class="toc-text">通知</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变化合成记录"><span class="toc-number">7.</span> <span class="toc-text">变化合成记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#存取器属性"><span class="toc-number">8.</span> <span class="toc-text">存取器属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用一个回调函数观察多个对象"><span class="toc-number">9.</span> <span class="toc-text">使用一个回调函数观察多个对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#大规模的变化"><span class="toc-number">10.</span> <span class="toc-text">大规模的变化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#观察数组"><span class="toc-number">11.</span> <span class="toc-text">观察数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#性能"><span class="toc-number">12.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为Object-observe-提供垫片"><span class="toc-number">13.</span> <span class="toc-text">为Object.observe()提供垫片</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#框架和Object-observe"><span class="toc-number">14.</span> <span class="toc-text">框架和Object.observe()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">15.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考链接"><span class="toc-number">16.</span> <span class="toc-text">参考链接</span></a></li></ol>
                </div>
            

            <ul>
<li>英文原文： <a href="http://www.html5rocks.com/en/tutorials/es7/observe/" target="_blank" rel="external">Data-binding Revolutions with Object.observe()</a> （需翻墙）</li>
<li><a href="http://div.io/topic/600" target="_blank" rel="external">参考</a></li>
</ul>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>一场变革即将到来。Javascript中的一项新特性将会颠覆之前你对于<strong>数据绑定</strong>的所有认识。它也将改变你所使用的MVC库观察模型中发生的修改以及更新的实现方式。你会看到，那些所有在意属性观察的应用性能将会得到巨大的提升。</p>
<p>我们很高兴的看到，<code>Object.observe()</code>已经正式加入到了Chrome 36 beta版本中。</p>
<p><code>Object.observe()</code>是未来ECMAScript标准之一，它是一个可以<strong>异步观察Javascript中对象变化的方法</strong>，而无需使用一个其他的JS库。它允许一个观察者接收一个<strong>按照时间排序的变化记录序列</strong>，这个序列描述的是一列被观察的对象所发生的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let's say we have a model with data</span></span><br><span class="line"><span class="keyword">var</span> model = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Which we then observe</span></span><br><span class="line"><span class="built_in">Object</span>.observe(model, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This asynchronous callback runs</span></span><br><span class="line">    changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Letting us know what changed</span></span><br><span class="line">        <span class="built_in">console</span>.log(change.type, change.name, change.oldValue);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当被观察的对象发生任何变化时，回调函数将会汇报这些变化：</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-001.png" alt=""></p>
<p>通过使用<code>Object.observe()</code>，你可以<a href="http://bitworking.org/news/2014/05/zero_framework_manifesto" target="_blank" rel="external">不需要使用任何框架</a>就能实现双向数据绑定。</p>
<p>但这并不意味着你就不应该使用一个框架。对于一些有着复杂业务逻辑的项目，经过精心设计的框架的重要性不言而喻，你应该继续使用它们。这些框架减轻了开发新手的工作量，而且只需要编写很少的代码就能够维护和实现一些模式并达到我们想要的目的。如果你不需要一个框架，你可以使用一个体积更小，针对性更强的库，比如<a href="http://polymer-project.org/" target="_blank" rel="external">Polymer</a>（它已经开始使用<code>Object.observe()</code>了）。</p>
<p>即便你已经重度依赖于一个<code>MV*</code>框架，<code>Object.observe()</code>仍然能为你的应用带来一些性能各方面的提升，它能够更快更简单的实现一些功能并维持同样的API。例如，在Angular以前的一个Benchmark测试中，对于一个Model中发生的变化，脏值检查对每次更新会花费40ms，而<code>Object.observe()</code>只会花费1-2ms（相当于20-40倍的性能提升）。</p>
<p>不需要冗长代码来实现的数据双向绑定还意味着你不需要通过轮询来发现变化，这将带来更长的电池使用时间！</p>
<p>如果你已经对<code>Object.observe()</code>有了一些了解，可以直接跳过简介这一节，或者接着阅读了解更多关于它能够解决的问题。</p>
<h1 id="我们要需要观察什么？"><a href="#我们要需要观察什么？" class="headerlink" title="我们要需要观察什么？"></a>我们要需要观察什么？</h1><p>当我们在讨论数据观察时，我们通常指的是对一些特定类型的数据变化保持关注：</p>
<ul>
<li>原始JavaScript对象中的变化</li>
<li>当属性被添加、改变、或者删除时的变化</li>
<li>当数组中的元素被添加或者删除时的变化</li>
<li>对象的原型发生的变化</li>
</ul>
<h1 id="数据绑定的重要性"><a href="#数据绑定的重要性" class="headerlink" title="数据绑定的重要性"></a>数据绑定的重要性</h1><p>当你开始关心<strong>模型-视图</strong>的控制分离时，数据绑定就会变成一件重要的事。HTML是一个非常好的声明机制，但是它完全是静态的。理想状态下，你想要在数据和DOM之间声明它们的关系，以便让DOM保持更新。这会让你节省很多由于写一些重复代码而浪费的时间。</p>
<p>当你拥有一个复杂的用户界面，你需要理清楚许多数据属性和许多视图中元素的关系时，数据绑定是非常有用的。这在我们今天需要创建的单页应用中非常常见。</p>
<p>通过在浏览器中原生的观察数据，我们给予了JavaScript框架（或者你编写的一些功能库）一种方式来实现对模型数据的变化进行观察而不需要依赖于我们今天正在使用的一些hack方法。</p>
<h1 id="现在使用的数据绑定方案是什么样子的"><a href="#现在使用的数据绑定方案是什么样子的" class="headerlink" title="现在使用的数据绑定方案是什么样子的"></a>现在使用的数据绑定方案是什么样子的</h1><h2 id="脏值检查"><a href="#脏值检查" class="headerlink" title="脏值检查"></a>脏值检查</h2><p>你以前曾经在那里看到过数据绑定？如果你在你的web应用中使用过一个现代MV*框架(例如Angular，Knockout)，那么你或许已经使用过数据绑定将数据绑定到你的DOM上了。为了复习一下，下面是一个电话列表应用的例子，在其中我们会将一个phones数组中的值（在JavaScript中定义）绑定到一个列表项目中以便于我们的数据和UI保持同步。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"controller.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-controller</span>=<span class="string">"PhoneListCtrl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"phone in phones"</span>&gt;</span></span><br><span class="line">                &#123;&#123;phone.name&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;phone.snippet&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js的controller如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phonecatApp = angular.module(<span class="string">'phonecatApp'</span>, []);</span><br><span class="line"></span><br><span class="line">phonecatApp.controller(<span class="string">'PhoneListCtrl'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">    $scope.phones = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'Nexus S'</span>,</span><br><span class="line">            <span class="string">'snippet'</span>: <span class="string">'Fast just got faster with Nexus S.'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'Motorola XOOM with Wi-Fi'</span>,</span><br><span class="line">            <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'MOTOROLA XOOM'</span>,</span><br><span class="line">            <span class="string">'snippet'</span>: <span class="string">'The Next, Next Generation tablet.'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>demo的地址在<a href="http://angular.github.io/angular-phonecat/step-2/app/" target="_blank" rel="external">这里</a>。</p>
<p>在任何时候，只要是底层的model数据发生了变化，我们在DOM中的列表也会跟着更新。Angular是怎么做到这一点的呢？在Angular的背后，有一个叫做<strong>脏值检查</strong>的东西。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-002.png" alt=""></p>
<p>脏值检查的基本原理就是只要任何时候数据发生了变化，这个库都会通过一个<strong><code>digest</code></strong>或者<strong><code>change cycle</code></strong>去检查变化是否发生了。在Angular中，一个<code>digest</code>循环意味着所有被监视的表达式都会被循环一遍以便查看其中是否有变化发生。它<a href="http://stackoverflow.com/questions/9682092/databinding-in-angularjs/9693933#9693933" target="_blank" rel="external">知道</a>一个模型之前的值，因此当变化发生时一个change事件将会被触发。对于开发者来说，这带来的一大好处就是你可以使用原生的JavaScript对象数据，它易于使用及整合。下面的图片展示的是一个非常糟糕的算法，它的开销非常大。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-003.png" alt=""></p>
<p>这个操作的开销和被监视的对象的数量是成正比的。我们可能需要做很多的脏治检查。同时我也需要一种方式去触发脏值检查，当某些数据可能发生改变时。有很多的框架使用了一些非常聪明的方法来解决这个问题，但是它们是否足够好目前还尚无定论。</p>
<p>web生态系统应该拥有更多的能力去创新和进化它自己的声明机制，例如：</p>
<ul>
<li>有约束的模型系统</li>
<li>自动的保存系统（例如：将变化保存在IndexedDB或者localStorage中）</li>
<li>容器对象（Ember，Backbone）</li>
</ul>
<p><a href="http://www.slideshare.net/mixonic/containers-di" target="_blank" rel="external">容器对象</a>是一个框架创建的对象，它能够在其中保存一些数据。它们拥有一些存取器去获取数据并且能够在你设置或者获取对象时捕获到这些行为并在内部进行广播。这是一种非常好的方式。它的性能很好，从算法上来说也不错。下面是一个使用Ember容器对象的一个简单例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container objects</span></span><br><span class="line">MyApp.president = Ember.Object.create(&#123;</span><br><span class="line">  name: <span class="string">"Barack Obama"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyApp.country = Ember.Object.create(&#123;</span><br><span class="line">  <span class="comment">// ending a property with "Binding" tells Ember to</span></span><br><span class="line">  <span class="comment">// create a binding to the presidentName property</span></span><br><span class="line">  presidentNameBinding: <span class="string">"MyApp.president.name"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Later, after Ember has resolved bindings</span></span><br><span class="line">MyApp.country.get(<span class="string">"presidentName"</span>);</span><br><span class="line"><span class="comment">// "Barack Obama"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data from the server needs to be converted</span></span><br><span class="line"><span class="comment">// Composes poorly with existing code</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，发现什么地方发生了变化的开销和发生改变的东西有着直接联系。现在你存在的另一个问题是你需要使用不同种类的对象。总的来说你需要将从服务器获取的数据进行转换以便它们是能够被观察到的。</p>
<p>目前的JS代码并不能很好的整合生成数据，因为这些代码一般会假设它们操作的是原生JavaScript对象，而不是一些特定的对象类似类型。</p>
<h1 id="介绍Object-observe"><a href="#介绍Object-observe" class="headerlink" title="介绍Object.observe()"></a>介绍Object.observe()</h1><p>我们真正想要的可能是两个世界中最好的东西 – 一种支持对原生数据对象（普通JavaScript对象）进行观察的方法，同时不需要每次都对所有东西进行脏值检查。它需要有良好的算法表现。它还需要能够很好的整合到各个平台中。这些都是<code>Object.observe()</code>能够带给我们的东西。</p>
<p>它允许我们对一个对象或者变异属性进行观察，并且在变化发生时得到及时通知。但是我们在这里不想看什么理论，让我们来看看代码！</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-004.png" alt=""></p>
<h2 id="Object-observe-和Object-unobserve"><a href="#Object-observe-和Object-unobserve" class="headerlink" title="Object.observe()和Object.unobserve()"></a>Object.observe()和Object.unobserve()</h2><p>让我们假设我们现在有一个简单的JavaScript对象，它代表一个模型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A model can be a simple vanilla object</span></span><br><span class="line"><span class="keyword">var</span> todoModel = &#123;</span><br><span class="line">    label: <span class="string">'Default'</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以制定一个比回调函数，用来处理对象上的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">    changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change, i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'what property changed? '</span> + change.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'how did it change? '</span> + change.type);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'whats the current value? '</span> + change.object[change.name]);</span><br><span class="line">        <span class="built_in">console</span>.log(change); <span class="comment">// all changes</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>当观察者回调函数被调用时，被观察的对象可能已经发生了多次改变，因此对于每一次变化，新的值（即每次变化以后的值）和当前值（最终的值）并不一定是相同的。</p>
<p>我们可以使用<code>Object.observe()</code>来观察这些变化，只要将对象作为第一个参数，而将回调函数作为第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.observe(todoModel, observer);</span><br></pre></td></tr></table></figure>
<p>我们现在对我们的Todos的模型对象做一些改变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todoModel.label = <span class="string">'Buy some more milk'</span>;</span><br></pre></td></tr></table></figure>
<p>看看控制台，我们现在得到了一些有用的信息！我们知道什么属性发生了变化，它是怎样变化的以及新的值是什么。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-005.png" alt=""></p>
<p>再见，脏值检查！你的墓碑应该被刻上Comic Sans字体。我们再来改变其他的属性。这次改变的是<code>completeBy</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todoModel.completeBy = <span class="string">'01/01/2014'</span>;</span><br></pre></td></tr></table></figure>
<p>正如我们所见的，我们又再一次得到了关于变化的报告：</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-006.png" alt=""></p>
<p>非常好。要是我们现在决定从对象中删除<code>completed</code>属性会怎么样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> todoModel.completed;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-007.png" alt=""></p>
<p>正如我们所见的，返回的变化报告包含了关于删除的信息。正如我们所期待的，新的值现在是<code>undefined</code>。那么，我们现在知道了你可以知道属性什么时候被添加。什么时候被删除。基本上来说，你可以知道一个对象上的属性集（’new’,’deleted’,’recongigured’）以及它的原型(proto)的变化。</p>
<p>在任何观察系统中，总是存在一个方法来停止观察。在这里，我们有<code>Object.unobserve()</code>方法，它的用法和<code>Object.observe()</code>一样但是可以像下面一样被调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.unobserve(todoModel, observer);</span><br></pre></td></tr></table></figure>
<p>正如下面所示，在使用该方法之后，任何的变化都不再作为一个变化列表记录返回。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-008.png" alt=""></p>
<h2 id="指定感兴趣的变化"><a href="#指定感兴趣的变化" class="headerlink" title="指定感兴趣的变化"></a>指定感兴趣的变化</h2><p>现在我们已经了解到了我们如何去获取一个被观察对象的变化列表。但是如果我们仅仅只对一个对象中的某些属性感兴趣该怎么办？人人都需要一个垃圾邮件过滤器。<code>Observer</code>可以通过一个列表指定一些我们想要看到的变化。我们需要通过<code>Object.observe()</code>的<strong>第三个参数</strong>来指定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.observe(obj, callback, opt_acceptList)</span><br></pre></td></tr></table></figure>
<p>现在我们来看一个如何使用的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like earlier, a model can be a simple vanilla object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> todoModel = &#123;</span><br><span class="line">    label: <span class="string">'Default'</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We then specify a callback for whenever mutations</span></span><br><span class="line"><span class="comment">// are made to the object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">    changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change, i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(change);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Which we then observe, specifying an array of change</span></span><br><span class="line"><span class="comment">// types we’re interested in</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(todoModel, observer, [<span class="string">'delete'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// without this third option, the change types provided</span></span><br><span class="line"><span class="comment">// default to intrinsic types</span></span><br><span class="line"></span><br><span class="line">todoModel.label = <span class="string">'Buy some milk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note that no changes were reported</span></span><br></pre></td></tr></table></figure>
<p>如果我们删除了这个标签，注意到这个类型的变化将会被报告：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> todoModel.label;</span><br></pre></td></tr></table></figure>
<p>如果你不指定一个列表，它默认将会报告<strong>固有的</strong>对象变化类型 (“add”, “update”, “delete”, “reconfigure”, “preventExtensions” (丢与那些不可扩展的对象是不可观察的))。</p>
<h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p><code>Object.observe()</code>也带有一些通知。它们并不像是你在手机上看到了通知，而是更加有有用。通知和变异观察者比较类似。它们发生在微任务的结尾。在浏览器的上下文，它几乎总是位于当前事件处理器的结尾。</p>
<p>这个时间点非常的重要因为基本上来说此时一个工作单元已经结束了，现在观察者已经开始它们的共走了。这是一个非常好的回合处理模型。</p>
<p>使用一个通知器的工作流程如下所示:</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-009.png" alt=""></p>
<p>现在我们通过一个例子来如何通过自定义一个通知器来处理一个对象的属性被设置或者被获取的情况。注意看代码中的注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a simple model</span></span><br><span class="line"><span class="keyword">var</span> model = &#123;</span><br><span class="line">    a: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// And a separate variable we'll be using for our model's getter in just a moment</span></span><br><span class="line"><span class="comment">// 定义一个单独的变量，我们即将使用它来作为我们的模型中的getter</span></span><br><span class="line"><span class="keyword">var</span> _b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a new property 'b' under 'a' with a custom getter and setter</span></span><br><span class="line"><span class="comment">// 在'a'下面定义一个新的属性'b'，并自定义一个getter和setter</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(model.a, <span class="string">'b'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _b;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Whenever 'b' is set on the model</span></span><br><span class="line">        <span class="comment">// notify the world about a specific type</span></span><br><span class="line">        <span class="comment">// of change being made. This gives you a huge</span></span><br><span class="line">        <span class="comment">// amount of control over notifications</span></span><br><span class="line">        <span class="comment">// 当'b'在模型中被设置时，注意一个特定类型的变化将会发生</span></span><br><span class="line">        <span class="comment">// 这将给你许多关于通知的控制器</span></span><br><span class="line">        <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>).notify(&#123;</span><br><span class="line">            type: <span class="string">'update'</span>,</span><br><span class="line">            name: <span class="string">'b'</span>,</span><br><span class="line">            oldValue: _b</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let's also log out the value anytime it gets</span></span><br><span class="line">        <span class="comment">// set for kicks</span></span><br><span class="line">        <span class="comment">// 在值发生变化时将会输出信息</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>, b);</span><br><span class="line"></span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up our observer</span></span><br><span class="line"><span class="comment">// 设置我们的观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>) </span>&#123;</span><br><span class="line">    changes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">change, i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(change);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Begin observing model.a for changes</span></span><br><span class="line"><span class="built_in">Object</span>.observe(model.a, observer);</span><br></pre></td></tr></table></figure>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-010.png" alt=""></p>
<p>现在当数据属性发生变化时(‘update’)我们将会得到报告。以及任何对象的实现也将会被报告(<code>notifier.notifyChange()</code>)。</p>
<p>多年的web平台开发经验告诉我们整合方法是你应该最先尝试的事情，因为它最容易去实现。但是它存在的问题是以它会创造一个从根本上来看就很未下的处理模型。如果你正在编写代码并且更新了一个对象的属性，你实际上并不想陷入这样一种困境：更新模型中的属性会最终导致任意一段代码去做任意一件事情。当你的函数正好运行到一半时，假设失效并不是什么理想的状况。</p>
<p>如果你是一个观察者，你并不想当某人正在做某事的时候被调用。你并不像在不连续的状态下被调用。因为这最终往往会导致更多的错误检查。你应该试着去容忍更多的情形，并且基本上来说它是一个很难去合作的模型。异步是一件更难处理的事情但是最终它会产生更好的模型。</p>
<p>上述问题的解决办法是变化合成记录(synthetic change records)。</p>
<h1 id="变化合成记录"><a href="#变化合成记录" class="headerlink" title="变化合成记录"></a>变化合成记录</h1><p>基本上来说，如果你想要存取器或者计算属性的话，你应该复杂在这些值发生改变时发出通知。这会导致一些额外的工作，但是它是这种机制第一类的特征，并且这些通知会连同来自余下的底层数据对象的通知一起被发布出来。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-011.png" alt=""></p>
<p>观察存取器或者计算属性的问题可以通过使用<code>notifier.notify</code>来解决 – 它也是<code>Object.observe()</code>的另外一部分。大多数的观察系统想要某些形式的观察导出值。有很多方法可以实现它。<code>Object.observe()</code>并没有用<em>正确的</em>方式进行判断。计算属性应该是存取器，当内部的（私有的）状态发生改变时它应该发出通知。</p>
<p>再一次声明，在web中应该有一些库来帮助我们进行通知并且帮助我们更好的实现计算属性（以及减少模板的使用）。</p>
<p>我们在这里会假设一个例子，这个例子中有一个<code>circle</code>类。在这里，我们有一个<code>citcle</code>，它有一个<code>radius</code>属性。在这里的情形中，<code>radius</code>是一个存取器，并且当它的值发生变化时它实际上会去通知自己值已经发生变化了。这些通知将会连同其他变化被传递到这个对象或者其他对象。本质上来说，如果你正在实现一个对象，你一定会想要拥有整合或者计算属性的对象，或者你想要想出一个策略如何让它运行。一旦你做了这件事，它将会适应你的整个系统。</p>
<p>看看下面的代码在开发者工具中是如何运行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> radius = r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">notifyAreaAndRadius</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      type: <span class="string">'update'</span>,</span><br><span class="line">      name: <span class="string">'radius'</span>,</span><br><span class="line">      oldValue: radius</span><br><span class="line">    &#125;)</span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      type: <span class="string">'update'</span>,</span><br><span class="line">      name: <span class="string">'area'</span>,</span><br><span class="line">      oldValue: <span class="built_in">Math</span>.pow(radius * <span class="built_in">Math</span>.PI, <span class="number">2</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'radius'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (radius === r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      notifyAreaAndRadius(radius);</span><br><span class="line">      radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'area'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.pow(radius, <span class="number">2</span>) * <span class="built_in">Math</span>.PI;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">      r = <span class="built_in">Math</span>.sqrt(a/<span class="built_in">Math</span>.PI);</span><br><span class="line">      notifyAreaAndRadius(radius);</span><br><span class="line">      radius = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change, i</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(change);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-012.png" alt=""></p>
<h1 id="存取器属性"><a href="#存取器属性" class="headerlink" title="存取器属性"></a>存取器属性</h1><p>在这里我们对于存取器属性有一个简短的提示。在前面我们提到了对于数据属性来说只有值得变化是能够被观察到的。而存取器属性和计算属性则无法被观察到。这是因为JavaScript中的存取器并没有真正的值的变化。一个存取器仅仅是一个函数集合。</p>
<p>如果你为一个存取器属性赋值,你仅仅只是调用了这个函数，并且在它看来值并没有发生变化。它仅仅只是让一些代码运行起来。</p>
<p>这里的问题在于我们在上面的例子中将存取器属性赋值为5.我们应该能够知道这里究竟发生了什么。这实际上是一个未解决的问题。这个例子说明了原因。对任何系统来说知道这究竟意味着什么是不可能的，因为在这里可以运行任意代码。每当存取器属性被访问时，它的值都会发生改变，因此询问它什么时候会发生变化并没有多大的意义。</p>
<h1 id="使用一个回调函数观察多个对象"><a href="#使用一个回调函数观察多个对象" class="headerlink" title="使用一个回调函数观察多个对象"></a>使用一个回调函数观察多个对象</h1><p><code>Object.observe()</code>上的另一个模式是使用单个回调观察者。这允许我们使用同一个回调函数堆多个不同的对象进行观察。这个回调函数在“微任务”的结尾将会把所有的变化都传递给它所观察的对象。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-013.png" alt=""></p>
<h1 id="大规模的变化"><a href="#大规模的变化" class="headerlink" title="大规模的变化"></a>大规模的变化</h1><p>也许你正在编写一个非常大的应用，并且经常需要处理大规模的变化。此时我们希望用一种更加紧凑的方式来描述影响很多属性的语义变化。</p>
<p><code>Object.observe()</code>使用两个特定的函数来解决这个问题：<code>notifier.performChange()</code>以及<code>notifier.notify()</code>，我们在上面已经介绍过这两个函数了。</p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-014.png" alt=""></p>
<p>我们可以从下面的例子中看到我们如何来描述大规模变化，在这个例子中定义了一个叫做<code>Thingy</code>的对象，其中包含几个数计算功能（multiply, increment, incrementAndMultiply）。只要其中一个功能被使用，它就会告诉系统一些包含特定变化的事情发生了。</p>
<p>例如： <code>notifier.performChange(‘foo’, performFooChangeFn)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Thingy</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">  <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thingy.MULTIPLY = <span class="string">'multiply'</span>;</span><br><span class="line">Thingy.INCREMENT = <span class="string">'increment'</span>;</span><br><span class="line">Thingy.INCREMENT_AND_MULTIPLY = <span class="string">'incrementAndMultiply'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thingy.prototype = &#123;</span><br><span class="line">  increment: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the system that a collection of work comprises</span></span><br><span class="line">    <span class="comment">// a given changeType. e.g</span></span><br><span class="line">    <span class="comment">// notifier.performChange('foo', performFooChangeFn);</span></span><br><span class="line">    <span class="comment">// notifier.notify('foo', 'fooChangeRecord');</span></span><br><span class="line">    notifier.performChange(Thingy.INCREMENT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a += amount;</span><br><span class="line">      <span class="keyword">this</span>.b += amount;</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      object: <span class="keyword">this</span>,</span><br><span class="line">      type: Thingy.INCREMENT,</span><br><span class="line">      incremented: amount</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  multiply: <span class="function"><span class="keyword">function</span>(<span class="params">amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    notifier.performChange(Thingy.MULTIPLY, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a *= amount;</span><br><span class="line">      <span class="keyword">this</span>.b *= amount;</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      object: <span class="keyword">this</span>,</span><br><span class="line">      type: Thingy.MULTIPLY,</span><br><span class="line">      multiplied: amount</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  incrementAndMultiply: <span class="function"><span class="keyword">function</span>(<span class="params">incAmount, multAmount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> notifier = <span class="built_in">Object</span>.getNotifier(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    notifier.performChange(Thingy.INCREMENT_AND_MULTIPLY, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.increment(incAmount);</span><br><span class="line">      <span class="keyword">this</span>.multiply(multAmount);</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    notifier.notify(&#123;</span><br><span class="line">      object: <span class="keyword">this</span>,</span><br><span class="line">      type: Thingy.INCREMENT_AND_MULTIPLY,</span><br><span class="line">      incremented: incAmount,</span><br><span class="line">      multiplied: multAmount</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以为我们的对象定义两个观察者： 一个用来捕获所有的变化，另一个将只会汇报我们定义的特定类型的变化 (<code>Thingy.INCREMENT</code>, <code>Thingy.MULTIPLY</code>, <code>Thingy.INCREMENTANDMULTIPLY</code>)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer, observer2 = &#123;</span><br><span class="line">    records: <span class="literal">undefined</span>,</span><br><span class="line">    callbackCount: <span class="number">0</span>,</span><br><span class="line">    reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.records = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.callbackCount = <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observer.callback = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(r);</span><br><span class="line">    observer.records = r;</span><br><span class="line">    observer.callbackCount++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observer2.callback = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">true<span class="built_in">console</span>.log(<span class="string">'Observer 2'</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thingy.observe = <span class="function"><span class="keyword">function</span>(<span class="params">thingy, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object.observe(obj, callback, optAcceptList)</span></span><br><span class="line">  <span class="built_in">Object</span>.observe(thingy, callback, [Thingy.INCREMENT,</span><br><span class="line">                                    Thingy.MULTIPLY,</span><br><span class="line">                                    Thingy.INCREMENT_AND_MULTIPLY,</span><br><span class="line">                                    <span class="string">'update'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thingy.unobserve = <span class="function"><span class="keyword">function</span>(<span class="params">thingy, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.unobserve(thingy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在可以开始玩弄一下代码了。我们先定义一个新的<code>Thingy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thingy = <span class="keyword">new</span> Thingy(<span class="number">2</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>对它进行观察并进行一些变化。有趣的事情发生了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observe thingy</span></span><br><span class="line"><span class="built_in">Object</span>.observe(thingy, observer.callback);</span><br><span class="line">Thingy.observe(thingy, observer2.callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Play with the methods thingy exposes</span></span><br><span class="line">thingy.increment(<span class="number">3</span>);               <span class="comment">// &#123; a: 5, b: 7 &#125;</span></span><br><span class="line">thingy.b++;                        <span class="comment">// &#123; a: 5, b: 8 &#125;</span></span><br><span class="line">thingy.multiply(<span class="number">2</span>);                <span class="comment">// &#123; a: 10, b: 16 &#125;</span></span><br><span class="line">thingy.a++;                        <span class="comment">// &#123; a: 11, b: 16 &#125;</span></span><br><span class="line">thingy.incrementAndMultiply(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// &#123; a: 26, b: 36 &#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-015.png" alt=""></p>
<p>位于这个<code>perform function</code>中的一切东西都可以被看作是<em>大型变化</em>进行的工作。接受<em>大型变化</em>的观察者仅仅只会接受<em>大型变化”</em>记录。那些不会接受底层变化的观察者都来源于<code>perform function</code>所做的事。</p>
<h1 id="观察数组"><a href="#观察数组" class="headerlink" title="观察数组"></a>观察数组</h1><p>我们已经讨论了如何观察一个对象，但是应该如何观察数组呢？</p>
<p><code>Array.observe()</code>是一个针对自身大型变化的方法 – 例如 – <code>splice</code>，<code>unshift</code>或者任何能够隐式影响数组长度的东西。在内部它使用了<code>notifier.performChange</code>(“splice”,…)。</p>
<p>下面是一个我们如何观察一个模型数组的例子，当底层数据发生一些变化时，我们将能够得到一个变化的列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> model = [<span class="string">'Buy some milk'</span>, <span class="string">'Learn to code'</span>, <span class="string">'Wear some plaid'</span>];</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.observe(model, <span class="function"><span class="keyword">function</span>(<span class="params">changeRecords</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Array observe'</span>, changeRecords, count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">model[<span class="number">0</span>] = <span class="string">'Teach Paul Lewis to code'</span>;</span><br><span class="line">model[<span class="number">1</span>] = <span class="string">'Channel your inner Paul Irish'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-016.png" alt=""></p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>考虑<code>Object.observe()</code>性能的方式是将它想成读缓存。基本上来说，在以下几种情形中，一个缓存是最佳选择（按照重要性排序）：</p>
<ol>
<li>读的频率决定着写的频率</li>
<li>你可以创造一个缓存，它可以在读数据期间将涉及到写数据的操作进行算法上的优化</li>
<li>写数据减慢的时间常数是可以接受的</li>
</ol>
<p><strong><code>Object.observe()</code>是为上述第一种情形设计的。</strong></p>
<p>脏值检查需要保留一个你所要观察数据的副本。这意味着在脏值检查中你需要一个额外的结构内存开销。脏值检查，一个作为权宜之计的解决方案，同时根本上也是一个脆弱的抽象，它可能会导致应用中一些不必要的复杂性。</p>
<p>脏值检查在任何数据可能发生变化的时候都必须要运行。这很明显并不是一个非常鲁棒的方法，并且任何实现脏值检查的途径都是有缺陷的（例如，在轮询中进行检查可能会造成视觉上的假象以及涉及到代码的紊乱情况）。脏值检查也需要注册一个全局的观察者，这很可能会造成内存泄漏，而Object.observe()会避免这一点。</p>
<p>我们现在来看一些数据。</p>
<p>下面的<a href="https://github.com/Polymer/observe-js/tree/master/benchmark" target="_blank" rel="external">基准测试</a>允许我们比较<strong>脏值检查</strong>和<code>Object.observe()</code>。图中比较的数据是<em>Observed-Object-Set-Size</em>和<em>Number-Of-Mutations</em>。</p>
<p>总的结果表明：<strong>脏值检查的性能和被观察的对象成正比，而``Object.observe()的性能和我们所做的改变成正比。</strong></p>
<p><strong>Dirty-checking</strong></p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-017.png" alt=""></p>
<p><strong>Chrome with Object.observe() switched on</strong></p>
<p><img src="http://7xkwt1.com1.z0.glb.clouddn.com/Object-observe-带来的数据绑定变革-018.png" alt=""></p>
<h1 id="为Object-observe-提供垫片"><a href="#为Object-observe-提供垫片" class="headerlink" title="为Object.observe()提供垫片"></a>为Object.observe()提供垫片</h1><p><code>Object.observe()</code>现在已经可以在Chrome 36 beta中使用，但是如果我们想要在其他浏览器中使用它该怎么办？Polymer中的<a href="https://github.com/Polymer/observe-js" target="_blank" rel="external">Observe-JS</a>是一个针对于那些没有原生实现<code>Object.observe()</code>浏览器的一个垫片，但是它不仅仅是作为垫片，同时也包含了许多有用的语法糖。它提供了一种整合的视角，它能够将所有变化总结起来并且提交一份关于变化的报告。它的好处主要体现在两点：</p>
<ol>
<li>你可以<strong>观察路径</strong>。这意味着你可以说，我想要从一个给定的对象中观察<code>foo.bar.baz</code>，只要这个路径的值发生了改变，你会得到通知。如果路径是错误的，将会返回<code>undefined</code>。</li>
</ol>
<p>下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; foo: &#123; bar: <span class="string">'baz'</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> PathObserver(obj, <span class="string">'foo.bar'</span>);</span><br><span class="line">observer.open(<span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// respond to obj.foo.bar having changed value.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li>它<strong>能够告诉你数组的拼接</strong>。数组拼接基本上来说是你为了将旧版本数组转换为新版本数组是需要进行了最基本的拼接操作。这是一种转换的类型或者是这个数组的不同视图。它是你想要将数组从旧状态变为新状态时需要进行的最基本的工作。</li>
</ol>
<p>下面是一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> ArrayObserver(arr);</span><br><span class="line">observer.open(<span class="function"><span class="keyword">function</span>(<span class="params">splices</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// respond to changes to the elements of arr.</span></span><br><span class="line">  splices.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">splice</span>) </span>&#123;</span><br><span class="line">    splice.index; <span class="comment">// index position that the change occurred.</span></span><br><span class="line">    splice.removed; <span class="comment">// an array of values representing the sequence of elements which were removed</span></span><br><span class="line">    splice.addedCount; <span class="comment">// the number of elements which were inserted.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="框架和Object-observe"><a href="#框架和Object-observe" class="headerlink" title="框架和Object.observe()"></a>框架和Object.observe()</h1><p>正如上面所提到的，使用<code>Object.observe()</code>能够给予框架和库中关于数据绑定的性能巨大的提升。</p>
<p>来自Ember的Yehuda Katz和Erik Bryn已经确定将会在Ember最近的修改版本中添加对<code>Object.observe()</code>的支持。来自Angular的Misko Hervy写了一份关于Angular 2.0的设计文档，其中的内容关于改善变化探测（change detection）。在将来，当<code>Object.observe()</code>在Chrome稳定版中出现时，Angular会使用<code>Object.observe()</code>来实现变化探测的功能，在此之前它们会选择使用<a href="https://github.com/angular/watchtower.js/" target="_blank" rel="external">Watchtower.js</a> – Angular自己的变化探测的实现方式。实在是太令人激动了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Object.observe()</code>是一个添加到web平台上非常强大的特性，你现在就可以开始使用它。</p>
<p>我们希望这项特征能够及时的登陆到更多的浏览器中，它能够允许JavaScript框架从本地对象观察的能力中获得更多性能上的提升。Chrome 36 beta及其以上的版本都能使用这项特性，在未来Opera发布的版本中这项特性也会得到支持。</p>
<p>现在就和JavaScript框架作者谈谈<code>Object.observe()</code>如何能够提高他们框架中数据绑定的性能。未来还有更多让人激动的时刻。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://wiki.ecmascript.org/doku.php?id=harmony:observe" target="_blank" rel="external">Object.observe() on the Harmony wiki</a></li>
<li><a href="http://bocoup.com/weblog/javascript-object-observe/" target="_blank" rel="external">Databinding with Object.observe() by Rick Waldron</a></li>
<li><a href="http://addyosmani.com/blog/the-future-of-data-binding-is-object-observe/" target="_blank" rel="external">Everything you wanted to know about Object.observe() - JSConf</a></li>
<li><a href="http://georgestefanis.com/blog/2014/03/25/object-observe-ES7.html" target="_blank" rel="external">Why Object.observe() is the best ES7 feature</a></li>
</ul>


            <div class="post-info">
    <p class="eof">- EOF -</p>
    <p class="copyright">All rights reserved <a href="http://gejiawen.github.io/about">@gejiawen</a>.</p>
    <p class="link">本文链接：<a href="http://blog.gejiawen.com/2014/10/30/intro-for-observe-and-data-binding/">http://blog.gejiawen.com/2014/10/30/intro-for-observe-and-data-binding/</a></p>

    <div class="share">
    分享本页：
    
        <div class="bdsharebuttonbox"><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a><a href="#" class="bds_more" data-cmd="more"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

    
    
</div>

</div>


            
    <section class="comment">
    <div class="ds-thread" data-thread-key="intro-for-observe-and-data-binding" data-title="Object.observe()带来的数据绑定变革" data-url="http://blog.gejiawen.com/2014/10/30/intro-for-observe-and-data-binding/" data-author-key="gejiawen"></div>
</section>


<script type="text/javascript">
var duoshuoQuery = {short_name:"gejiawen-blog"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>





        </div>
    </div>
</article>

    <footer id="footer">
        <div id="bottom-tip">
            蛋糕仙人 —— <small>技术人需要危机感</small>
        </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/gejiawen/hexadillax2" target="_blank">Hexadillax2</a> 主题</small><br />
        <!--<small>如果你访问github速度过慢，可移步本站的备份站点<a href="http://gejiawen.gitcafe.io">gejiawen.gitcafe.io</a></small><br />-->
        <small>&copy; 2017 <a href="http://blog.gejiawen.com" target="_blank">gejiawen</a>&nbsp;<a href="http://www.miitbeian.gov.cn/" target="_blank">皖ICP备16008778号</a></small>
    </footer>
    
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e4dd778a6204eb51e4f25460e37481ad";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script type="text/javascript" src="http://tajs.qq.com/stats?sId=58628762" charset="UTF-8"></script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-51347904-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>


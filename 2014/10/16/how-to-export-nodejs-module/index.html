

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="gejiawen">
    
    <meta name="description" content="英文原文： Export This: Interface Design Patterns for Node.js Modules
当你在Node中require一个模块时，你从返回的结果中得到了什么？当你编写一个Node模块时，在设计模块的接口时你有哪些选择？
今天我们将讨论七种Node.js模块接">
    
    

    
    <link rel="alternative" href="atom.xml" title="蛋糕仙人" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>如何导出NodeJS模块 | 蛋糕仙人 · 技术人需要危机感</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script>
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <meta name="baidu-site-verification" content="SzJ3MGdmeo" />


    <meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />


    <!--<meta name="baidu-site-verification" content="SzJ3MGdmeo" />-->
    <!--<meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />-->

</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://blog.gejiawen.com" title="蛋糕仙人">蛋糕仙人</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a class="max-width max-w300" title="技术人需要危机感" href="/feelings">技术人需要危机感</a>
                    </li>
                </ul>
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index">
                        <a href="/" target="">首页</a>
                    </li>
                    
                    <li id="nav-archives">
                        <a href="/archives" target="">归档</a>
                    </li>
                    
                    <li id="nav-categories">
                        <a href="/categories" target="">分类</a>
                    </li>
                    
                    <li id="nav-tags">
                        <a href="/tags" target="">标签</a>
                    </li>
                    
                    <li id="nav-pick">
                        <a href="http://book.gejiawen.com/fucking-days-to-be-a-coder" target="_blank">拾遗</a>
                    </li>
                    
                    <li id="nav-about">
                        <a href="/about" target="">关于</a>
                    </li>
                    

                    <li id="nav-github"><a href="https://github.com/gejiawen" target="_blank">GitHub</a></li>
                    <!--<li id="nav-rss"><a href="/atom.xml" target="_blank">Rss</a></li>-->
                    <li id="nav-search"><input type="text" id="search" placeholder="search" /></li>
                </ul>
            </div>
        </div>
    </nav>

    <script>
    var bgRoot = "http://7xkwt1.com1.z0.glb.clouddn.com/background-";
    var bgLength = "74";
    var bgRandom = false;
    var bgImage = "http://7xkwt1.com1.z0.glb.clouddn.com/background-64.jpg";

    $(function() {
        // page-id...
        var pageId = "2014/10/16/how-to-export-nodejs-module/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";

        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>如何导出NodeJS模块</h1>

        <div class="time-info">
            
<span class="article-tags">
    
    Tags: <a href="/tags/nodejs/">nodejs</a>&nbsp;<a href="/tags/漫游NodeJS系列/">漫游NodeJS系列</a>&nbsp;<a href="/tags/翻译/">翻译</a>&nbsp;
</span>



<span class="article-categories">
    Category:
    <a class="article-category-link" href="/categories/NODEJS/">NODEJS</a>
</span>


        </div>
        <div class="time-info">
            发表: <time datetime="2014-10-16T07:55:39.000Z"
                       itemprop="datePublished">2014-10-16 15:55:39</time>
            
            更新: <time datetime="2017-01-15T17:16:24.000Z"
                       itemprop="dateModified">2017-01-16 01:16:24</time>
            
        </div>

        <div class="post-body-inner">
            
                <div id="toc" class="toc-article well">
                    <strong class="toc-title">大纲</strong>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#require-exports和module-exports"><span class="toc-number">1.</span> <span class="toc-text">require,exports和module.exports</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出一个命名空间"><span class="toc-number">2.</span> <span class="toc-text">导出一个命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出一个函数"><span class="toc-number">3.</span> <span class="toc-text">导出一个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出一个高阶函数"><span class="toc-number">4.</span> <span class="toc-text">导出一个高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出一个构造函数"><span class="toc-number">5.</span> <span class="toc-text">导出一个构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#导出一个单体"><span class="toc-number">6.</span> <span class="toc-text">导出一个单体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展一个全局对象"><span class="toc-number">7.</span> <span class="toc-text">扩展一个全局对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运用一个猴子补丁"><span class="toc-number">8.</span> <span class="toc-text">运用一个猴子补丁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol>
                </div>
            

            <p>英文原文： <a href="http://bites.goodeggs.com/posts/export-this/" target="_blank" rel="external">Export This: Interface Design Patterns for Node.js Modules</a></p>
<p>当你在Node中require一个模块时，你从返回的结果中得到了什么？当你编写一个Node模块时，在设计模块的接口时你有哪些选择？</p>
<p>今天我们将讨论七种Node.js模块接口设计模式，在实际工作中，它们经常会被混合起来使用：</p>
<ol>
<li>导出一个命名空间</li>
<li>导出一个函数</li>
<li>导出一个高阶函数</li>
<li>导出一个构造函数</li>
<li>导出一个单体</li>
<li>扩展一个全局对象</li>
<li>运用一个猴子补丁(Monkey Patch)</li>
</ol>
<h2 id="require-exports和module-exports"><a href="#require-exports和module-exports" class="headerlink" title="require,exports和module.exports"></a>require,exports和module.exports</h2><p>首先我们来回顾一下基础。</p>
<p>在Node中，<code>require</code>一个文件实际上实在<code>require</code>这个文件定义的模块。所有的模块都拥有一个对隐式<code>module</code>对象的引用，当你调用<code>require</code>时实际上返回的是<code>module.exports</code>属性。对于<code>module.exports</code>的引用同样也能写成<code>exports</code>。</p>
<p>在每一个模块的第一行都隐式的包含了一行下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果你想要导出一个函数，你需要将这个函数赋值给<code>module.exports</code>。将一个函数赋值给<code>exoports</code>将会为<code>exports</code>引用重新赋值，但是<code>module.exports</code>依然会指向原始的空对象。</p>
<p>因此我们可以像这样来定义一个<code>function.js</code>模块来导出一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;name: <span class="string">'Jane'</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在另一个文件中require这个模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fund = <span class="built_in">require</span>(<span class="string">'./function'</span>);</span><br></pre></td></tr></table></figure>
<p><code>require</code>的一个重要行为就是它缓存了<code>module.exports</code>的值并且在未来再次调用<code>require</code>时返回同样的值。它依据被<code>require</code>文件的绝对路径来进行缓存。因此如果你想要你的模块返回不同的值，你应该导出一个在再次调用时能返回不同值的函数。</p>
<p>为了证明这点，我们在Node REPL中进行一些操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; f1 = <span class="built_in">require</span>(<span class="string">'/Users/alon/Projects/export_this/function'</span>);</span><br><span class="line">[<span class="built_in">Function</span>]</span><br><span class="line">&gt; f2 = <span class="built_in">require</span>(<span class="string">'./function'</span>); <span class="comment">//同样的位置</span></span><br><span class="line">&gt; f1 === f2</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; f1() === f2()</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可以看到<code>require</code>返回了同一个函数实例但是由函数调用返回的对象是完全不同的。</p>
<p>更详细的信息你可以参看Node模块系统的文档。</p>
<p>现在我们开始正式进入接口设计模式。</p>
<h2 id="导出一个命名空间"><a href="#导出一个命名空间" class="headerlink" title="导出一个命名空间"></a>导出一个命名空间</h2><p>一个简单而常用的模式是导出一个拥有若干属性的对象，这些属性主要是函数但是不限于函数。这种方式允许代码通过<code>require</code>一个模块在一个命名空间下获取一组相关联的功能。</p>
<p>当你<code>require</code>了一个导出命名空间的模块，你通常会把整个命名空间赋值给一个变量来使用它的成员，或者将它的成员直接赋值给本地变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">    readFile = fs.readFile,</span><br><span class="line">    ReadStream = fs.ReadStream;</span><br><span class="line"></span><br><span class="line">readFile(<span class="string">'./file.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile contents: '%s'"</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ReadStream(<span class="string">'./file.txt'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ReadStream contents: '%s'"</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是fs核心模块中的一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = exports;</span><br></pre></td></tr></table></figure>
<p>它首先将本地变量fs赋值为隐式导出对象<code>exports</code>然后将函数引用赋值为fs的属性。因为fs指向<code>exports</code>并且<code>exports</code>是当你调用require(’fs’)时返回的对象，因此任何赋值给fs的东西在你通过<code>require</code>获取的对象中都可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile = <span class="function"><span class="keyword">function</span>(<span class="params">path,options,callback_</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何东西都是一个公平的游戏。它接下来会导出一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.ReadStream = ReadStream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当导出一个命名空间时，你可以将属性赋值于给<code>exports</code>或者fs模块，或者将一个新对象复制给<code>module.exports</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    version: <span class="string">'1.0'</span>,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>导出一个命名空间的普遍用法是导出其他模块的根对象以便一次<code>require</code>就能够获取若干个模块。在我之前的项目Good Eggs中，我们将每个分开的子模块都出了一个模型构造函数并且接着编写了一个能导出所有模型的index文件。这允许我们可以在一个<code>models</code>命名空间下获取所有的<code>model</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> models = <span class="built_in">require</span>(<span class="string">'./models'</span>),</span><br><span class="line">    User = models.User,</span><br><span class="line">    Product = models.Product;</span><br></pre></td></tr></table></figure>
<p>对于CoffeeScript用户，析构赋值（<a href="http://coffeescript.org/#destructuring" target="_blank" rel="external">restructuring assignment</a>）使得这个工作更加轻松了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;User, Product&#125; = <span class="built_in">require</span> <span class="string">'./models'</span></span><br></pre></td></tr></table></figure>
<p><code>index.js</code>文件看起来是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.User = <span class="built_in">require</span>(<span class="string">'./user'</span>);</span><br><span class="line">exports.Person = <span class="built_in">require</span>(<span class="string">'./person'</span>);</span><br></pre></td></tr></table></figure>
<p>事实上，我们使用一个小巧的库来require所有的子文件并且将它们使用驼峰命名法导出以便<code>index.js</code>文件实际上能够读取下面内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = require(&apos;../lib/require_siblings&apos;)(__filename);</span><br></pre></td></tr></table></figure>
<h2 id="导出一个函数"><a href="#导出一个函数" class="headerlink" title="导出一个函数"></a>导出一个函数</h2><p>另一个模式是导出一个函数作为一个模块的接口。一个普遍的用法是导出一个在调用时能返回一个兑现高的工厂函数。在使用<code>Express.js</code>时我们这样编写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/hello'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send <span class="string">"Hi there! We're using Express v"</span> + express.version;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由Express导出的这个函数被用来创建一个新的Express应用。在你自己使用这种模式时，你的工厂函数可能需要接收一些参数来配置或者初始化返回的对象。</p>
<p>为了导出一个函数，你需要将你的函数赋值给<code>module.exports</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = createApplication;</span><br><span class="line">...</span><br><span class="line">function createApplication () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子将<code>createApplication</code>函数赋值给了<code>module.exports</code>然后赋值给隐式的<code>exports</code>变量。现在<code>exports</code>就是模块导出的函数。</p>
<p>Express中同样将这个导出的函数作为命令空间来使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.version = <span class="string">'3.1.1'</span>;</span><br></pre></td></tr></table></figure>
<p>要注意的一点是没有什么阻止我们将导出的函数作为命令空间使用，它能够暴露出对于其他函数、构造函数或者对象的引用。</p>
<p>当导出一个函数时，最佳实践是位这个函数命名以便它能在栈追踪中出现。注意到下面两个例子的的栈追踪的不同之处：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bomb1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bomb2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bomb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$ node</span><br><span class="line">&gt; bomb = <span class="built_in">require</span>(<span class="string">'./bomb1'</span>);</span><br><span class="line">[<span class="built_in">Function</span>]</span><br><span class="line">&gt; bomb()</span><br><span class="line"><span class="built_in">Error</span>: boom</span><br><span class="line">    at <span class="built_in">module</span>.exports (<span class="regexp">/Users/</span>alon/Projects/export_this/bomb1.js:<span class="number">2</span>:<span class="number">9</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&gt; bomb = <span class="built_in">require</span>(<span class="string">'./bomb2'</span>);</span><br><span class="line">[<span class="built_in">Function</span>: bomb]</span><br><span class="line">&gt; bomb()</span><br><span class="line"><span class="built_in">Error</span>: boom</span><br><span class="line">    at bomb (<span class="regexp">/Users/</span>alon/Projects/export_this/bomb2.js:<span class="number">2</span>:<span class="number">9</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在导出一个函数的情形中有许多值得特别说明的点。</p>
<h2 id="导出一个高阶函数"><a href="#导出一个高阶函数" class="headerlink" title="导出一个高阶函数"></a>导出一个高阶函数</h2><p>一个高阶函数，或者函子(functor)，是一个接收一个或多个函数作为输入或者输出的函数。我们将讨论后面一种情形 – 即一个<strong>返回函数的函数</strong>。</p>
<p>当你想要从你的模块返回一个函数但是需要获取控制函数行为的输入时，导出一个高阶函数是一个非常有用的模式。</p>
<p>Connect中间件提供了许多对于Express和其他web框架的插件功能。一个中间件就是一个接收三个参数 – <code>(req</code>,<code>res</code>,<code>next)</code> – 的函数。这样的用法在connect中间件中是为了导出一个在调用时返回一个中间件函数的函数。这允许导出的函数接收能够被用于配置中间件以及在中间件的闭包作用域中可用的变量，当它在处理一个请求时。</p>
<p>例如，connect中的<code>query</code>中间件在Express中被哟关于解析查询字符串变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'connect'</span>),</span><br><span class="line">    query = <span class="built_in">require</span>(<span class="string">'connect/lib/middleware/query'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(query(&#123;maxKeys: <span class="number">100</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>query模块的源代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>),</span><br><span class="line">    parse = <span class="built_in">require</span>(<span class="string">'../utils'</span>).parseUrl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!req.query) &#123;</span><br><span class="line">            req.query = ~req.url.indexOf(<span class="string">'?'</span>) ? qs.parse(parse(req).query, options) : &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个通过query中间件的请求，在整个闭包作用域中都可用的<code>options</code>参数将单独传递给Node的核心模块qs模块。</p>
<p>这个设计模式是你在工作中非常常用且非常灵活的一个模式。</p>
<h2 id="导出一个构造函数"><a href="#导出一个构造函数" class="headerlink" title="导出一个构造函数"></a>导出一个构造函数</h2><p>我们在JavaScript以构造函数的方式定义类并且使用<code>new</code>关键字创建类的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi, I'm Jane."</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.greet()); <span class="comment">// prints: Hi, I'm Jane</span></span><br></pre></td></tr></table></figure>
<p>这种设计模式实现了<strong>一个文件一个类</strong>并且使得你的项目组织结构更加清晰，使得其他的开发者能够轻松发现类的实现方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="built_in">require</span>(<span class="string">'./person'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br></pre></td></tr></table></figure>
<p>实现的方式如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi, I'm "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Person;</span><br></pre></td></tr></table></figure>
<h2 id="导出一个单体"><a href="#导出一个单体" class="headerlink" title="导出一个单体"></a>导出一个单体</h2><p>当你想要你的模块的所有用户来分享一个类的实例的状态和行为时你需要导出一个单体。</p>
<p>Mongoose是一个对象-文档映射库，它被用来创建永久保存在MongoDB中的富结构域对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cat = mongoose.model(<span class="string">'Cat'</span>, &#123; name: <span class="built_in">String</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kitty = <span class="keyword">new</span> Cat(&#123; name: <span class="string">'Zildjian'</span> &#125;);</span><br><span class="line">kitty.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'meow'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们require Mongoose时返回的mongoose对象是什么？在内部，mongoose模块是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mongoose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = exports = <span class="keyword">new</span> Mongoose();</span><br></pre></td></tr></table></figure>
<p>由于require缓存了所有赋值给<code>module.exports</code>的值，所有对于<code>require(&#39;mongoose&#39;)</code>的调用那个将会返回同一个实例以确保它在我们的应用中是一个单体。Mongoose使用面向对象设计模式来压缩及解耦功能，保持状态并且支持可读性与可理解行，但是通过创建并导出Mongoose类的一个实例来创建一个面向用户的简单接口。</p>
<p>如果用户需要，Mongoose也会将这个单体实例作为命名空间来使用以确保其他的构造函数也可以使用，其中包括Mongoose构造函数本身。你可能需要使用Mongoose构造器函数来创建连接到其他MongoDB数据库的实例。</p>
<p>在内部，Mongoose是这样做的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mongoose.prototype.Mongoose = Mongoose;</span><br></pre></td></tr></table></figure>
<p>因此你可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>),</span><br><span class="line">    Mongoose = mongoose.Mongoose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myMongoose = <span class="keyword">new</span> Mongoose();</span><br><span class="line">myMongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="扩展一个全局对象"><a href="#扩展一个全局对象" class="headerlink" title="扩展一个全局对象"></a>扩展一个全局对象</h2><p>一个被require的模块能做的不仅仅是导出一个值。他可能够修改全局对象或者require其他模块时返回的对象。它可以定义一个新的全局对象。它可以只扩展一个对象或者在扩展一个全局对象的基础上导出一些有用的东西。</p>
<p>当你需要在你的对象中扩展或者改变全局对象的行为时你需要使用这个模式。虽然饱含争议并且应该谨慎使用（尤其是在开源项目中），该模式确是一个必不可少的模式。</p>
<p><code>Should.js</code>是一个在单元测试中使用的断言库。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">'Jane'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.name.should.equal(<span class="string">'Jane'</span>);</span><br></pre></td></tr></table></figure>
<p>Should.js通过在对象中扩展了一个不可枚举的属性<code>should</code>来为单元测试中编写断言提供一个清晰的语法。在内部，should.js是这么做的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Assertion(util.isWrapperType(obj) ? obj.valueOf(): obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">exports = <span class="built_in">module</span>.exports = should;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'should'</span>, &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> should(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意到<code>Should.js</code>导出了一个<code>should</code>函数，它的主要用途是为<code>Object</code>添加<code>should</code>属性。</p>
<h2 id="运用一个猴子补丁"><a href="#运用一个猴子补丁" class="headerlink" title="运用一个猴子补丁"></a>运用一个猴子补丁</h2><p>这里说的<strong>猴子补丁</strong>指的是<em>在运行过程中对类或者模块进行动态的修改，目的是为了给第三方代码添加一个补丁</em>。</p>
<p>当一个存在的模块没有提供你需要的功能时你可以实现一个模块作为它的补丁。这个模式是前面一个模式的变形。它并不是像上一个模式一样对全局对象进行修改，而是依靠Node模块系统的缓存行为对一个模块的同一个实例添加补丁以便当该模块被其他代码require时仍然能返回修改过的对象。</p>
<p>默认情形下Mongoose会将MongoDB的集合以小写和复数来命名。对于一个叫做<code>CreditCardAccountEntry</code>的集合最终存储在MongoDB中的名字叫做<code>creditcardaccountentries</code>。但是我想要它的名字为<code>credit_card_account_entries</code>并且我想要全局使用这种行为。</p>
<p>下面是一个针对mongoose.model的补丁模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>).Mongoose;</span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> model = Mongoose.prototype.model;</span><br><span class="line"><span class="keyword">var</span> modelWithUnderScoreCollectionName = <span class="function"><span class="keyword">function</span>(<span class="params">name, schema, collection, skipInit</span>) </span>&#123;</span><br><span class="line">    collection = collection || _(name).chain().underscore().pluralize().value();</span><br><span class="line">    model.call(<span class="keyword">this</span>, name, schema, collection, skipInit);</span><br><span class="line">&#125;;</span><br><span class="line">Mongoose.prototype.model = modelWithUnderScoreCollectionName;</span><br></pre></td></tr></table></figure>
<p>当这个模块第一次被require时，它require了mongoose，重定义了Mongoose.prototype.model并且将它代理返回原生的model。现在所有Mongoose的实例都将拥有新的欣行为。注意到它并没有修改exports因此通过require返回的值还是默认的空exports对象。</p>
<p>另外，如果你选择对已有模块运用一个猴子补丁，最好使用上面例子中的链式技巧。你在猴子补丁中添加你的行为然后这些行为将会代理回到原生的实现方式。虽然这种方式并不是很简单，但是它是对于第三方代码最好的添加补丁的方式，它允许你利用未来库的升级并且将你的补丁和其他补丁的冲突降低到最小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Node模块系统对于封装功能以及创建清晰的接口提供了一种非常简单的机制。希望上面提到的几种设计模式对于你有所帮助。</p>


            <div class="post-info">
    <p class="eof">- EOF -</p>
    <p class="copyright">All rights reserved <a href="http://gejiawen.github.io/about">@gejiawen</a>.</p>
    <p class="link">本文链接：<a href="http://blog.gejiawen.com/2014/10/16/how-to-export-nodejs-module/">http://blog.gejiawen.com/2014/10/16/how-to-export-nodejs-module/</a></p>

    <div class="share">
    分享本页：
    
        <div class="bdsharebuttonbox"><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a><a href="#" class="bds_more" data-cmd="more"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

    
    
</div>

</div>


            
    <section class="comment">
    <div class="ds-thread" data-thread-key="how-to-export-nodejs-module" data-title="如何导出NodeJS模块" data-url="http://blog.gejiawen.com/2014/10/16/how-to-export-nodejs-module/" data-author-key="gejiawen"></div>
</section>


<script type="text/javascript">
var duoshuoQuery = {short_name:"gejiawen-blog"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>





        </div>
    </div>
</article>

    <footer id="footer">
        <div id="bottom-tip">
            蛋糕仙人 —— <small>技术人需要危机感</small>
        </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/gejiawen/hexadillax2" target="_blank">Hexadillax2</a> 主题</small><br />
        <!--<small>如果你访问github速度过慢，可移步本站的备份站点<a href="http://gejiawen.gitcafe.io">gejiawen.gitcafe.io</a></small><br />-->
        <small>&copy; 2017 <a href="http://blog.gejiawen.com" target="_blank">gejiawen</a>&nbsp;<a href="http://www.miitbeian.gov.cn/" target="_blank">皖ICP备16008778号</a></small>
    </footer>
    
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e4dd778a6204eb51e4f25460e37481ad";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script type="text/javascript" src="http://tajs.qq.com/stats?sId=58628762" charset="UTF-8"></script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-51347904-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>




<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="author" content="gejiawen">
    
    <meta name="description" content="感谢Node.js开发指南，参考了它的附录部分内容。
作用域Javascript中的作用域是通过函数来确定的，这一点与C、Java等静态语言有一些不一样的地方。
最简单的例子1234if (true) &amp;#123;    var a =  &#39;Value&#39;;&amp;#125;console.log(a); // Value
上面的代码片段将会输出Value。（在浏览器环境中）
更加common的例子再来一个更加common的例子，
12345678910var a1 = &#39;Valve&#39;;var foo1 = function() &amp;#123;    console.log(a1);&amp;#125;;foo1(); // Valuevar foo2 = function() &amp;#123;    var a1 = &#39;DOTA2&#39;;    console.log(a1);&amp;#125;foo2(); // DOTA2
显然，foo1的结果是Value，foo2的结果是DOTA2，这应该很容易理解。
有点迷惑的例子接下来这个例子将会让人感到迷惑，
123456var a1 = &#39;mercurial&#39;;var foo = function() &amp;#123;    console.log(a1);    var a1 = &#39;git&#39;;&amp;#125;foo(); // undefined
此时，结果将会是undefined。">
    
    

    
    <link rel="alternative" href="atom.xml" title="蛋糕仙人" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Javascript中几个高级语言特性 | 蛋糕仙人 · 技术人需要危机感</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script>
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <meta name="baidu-site-verification" content="SzJ3MGdmeo" />


    <meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />


    <!--<meta name="baidu-site-verification" content="SzJ3MGdmeo" />-->
    <!--<meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />-->

</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://blog.gejiawen.com" title="蛋糕仙人">蛋糕仙人</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a class="max-width max-w300" title="技术人需要危机感" href="/feelings">技术人需要危机感</a>
                    </li>
                </ul>
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index">
                        <a href="/" target="">首页</a>
                    </li>
                    
                    <li id="nav-archives">
                        <a href="/archives" target="">归档</a>
                    </li>
                    
                    <li id="nav-categories">
                        <a href="/categories" target="">分类</a>
                    </li>
                    
                    <li id="nav-tags">
                        <a href="/tags" target="">标签</a>
                    </li>
                    
                    <li id="nav-pick">
                        <a href="http://book.gejiawen.com/fucking-days-to-be-a-coder" target="_blank">拾遗</a>
                    </li>
                    
                    <li id="nav-about">
                        <a href="/about" target="">关于</a>
                    </li>
                    

                    <li id="nav-github"><a href="https://github.com/gejiawen" target="_blank">GitHub</a></li>
                    <!--<li id="nav-rss"><a href="/atom.xml" target="_blank">Rss</a></li>-->
                    <li id="nav-search"><input type="text" id="search" placeholder="search" /></li>
                </ul>
            </div>
        </div>
    </nav>

    <script>
    var bgRoot = "http://7xkwt1.com1.z0.glb.clouddn.com/background-";
    var bgLength = "74";
    var bgRandom = false;
    var bgImage = "http://7xkwt1.com1.z0.glb.clouddn.com/background-64.jpg";

    $(function() {
        // page-id...
        var pageId = "2014/09/19/some-javascript-advanced-feature/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";

        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>Javascript中几个高级语言特性</h1>

        <div class="time-info">
            
<span class="article-tags">
    
    Tags: <a href="/tags/js/">js</a>&nbsp;
</span>



<span class="article-categories">
    Category:
    <a class="article-category-link" href="/categories/JAVASCRIPT/">JAVASCRIPT</a>
</span>


        </div>
        <div class="time-info">
            发表: <time datetime="2014-09-19T09:12:58.000Z"
                       itemprop="datePublished">2014-09-19 17:12:58</time>
            
            更新: <time datetime="2017-01-15T17:16:24.000Z"
                       itemprop="dateModified">2017-01-16 01:16:24</time>
            
        </div>

        <div class="post-body-inner">
            
                <div id="toc" class="toc-article well">
                    <strong class="toc-title">大纲</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#作用域"><span class="toc-number">1.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最简单的例子"><span class="toc-number">1.1.</span> <span class="toc-text">最简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更加common的例子"><span class="toc-number">1.2.</span> <span class="toc-text">更加common的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有点迷惑的例子"><span class="toc-number">1.3.</span> <span class="toc-text">有点迷惑的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套作用域"><span class="toc-number">1.4.</span> <span class="toc-text">嵌套作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态作用域"><span class="toc-number">1.5.</span> <span class="toc-text">静态作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局作用域"><span class="toc-number">1.6.</span> <span class="toc-text">全局作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#闭包"><span class="toc-number">2.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包解释"><span class="toc-number">2.1.</span> <span class="toc-text">闭包解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包的应用场景"><span class="toc-number">2.2.</span> <span class="toc-text">闭包的应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number">3.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建和访问"><span class="toc-number">3.1.</span> <span class="toc-text">创建和访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply和call"><span class="toc-number">3.2.</span> <span class="toc-text">apply和call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind方法"><span class="toc-number">3.3.</span> <span class="toc-text">bind方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prototype"><span class="toc-number">3.4.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型及基于原型的面向对象"><span class="toc-number">3.5.</span> <span class="toc-text">原型及基于原型的面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的复制"><span class="toc-number">3.6.</span> <span class="toc-text">对象的复制</span></a></li></ol></li></ol>
                </div>
            

            <p><em>感谢Node.js开发指南，参考了它的附录部分内容。</em></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>Javascript中的作用域是通过函数来确定的，这一点与<code>C</code>、<code>Java</code>等静态语言有一些不一样的地方。</p>
<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a =  <span class="string">'Value'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Value</span></span><br></pre></td></tr></table></figure>
<p>上面的代码片段将会输出Value。（在浏览器环境中）</p>
<h2 id="更加common的例子"><a href="#更加common的例子" class="headerlink" title="更加common的例子"></a>更加common的例子</h2><p>再来一个更加common的例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="string">'Valve'</span>;</span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a1);</span><br><span class="line">&#125;;</span><br><span class="line">foo1(); <span class="comment">// Value</span></span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="string">'DOTA2'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a1);</span><br><span class="line">&#125;</span><br><span class="line">foo2(); <span class="comment">// DOTA2</span></span><br></pre></td></tr></table></figure>
<p>显然，<code>foo1</code>的结果是Value，<code>foo2</code>的结果是DOTA2，这应该很容易理解。</p>
<h2 id="有点迷惑的例子"><a href="#有点迷惑的例子" class="headerlink" title="有点迷惑的例子"></a>有点迷惑的例子</h2><p>接下来这个例子将会让人感到迷惑，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="string">'mercurial'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a1);</span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="string">'git'</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此时，结果将会是<code>undefined</code>。</p>
<a id="more"></a>
<p>因为在函数foo内部的a1将会覆盖函数外部的变量a1，js搜索作用域是按照从内到外的，而且当执行到console.log时，函数作用域内部的a1还尚未被初始化，所以会输出undefined。</p>
<p>其实这里还涉及到一个<em>变量悬置</em>的概念，即在Javascript的函数中，无论在何处声明或者初始化的变量都等效于函数的起始位置声明，在实际位置赋值。如下，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'ok'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码等效于，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a; <span class="comment">// 注意看这里！</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    a = <span class="string">'ok'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还有一点需要说明的就是，<strong>未定义变量</strong>和<strong>定义但未被初始化的变量</strong>，虽然他们的值输出都是undefined，但是在js内部的实现上还是有区别的。未定义的变量存在于js的局部语义表上，但是未被分配内存，而定义却未初始化的变量时实际分配了内存的。</p>
<h2 id="嵌套作用域"><a href="#嵌套作用域" class="headerlink" title="嵌套作用域"></a>嵌套作用域</h2><p>接下来这个例子将会演示函数作用域的嵌套，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="string">'foo'</span>;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a1 = <span class="string">'foo1'</span>;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a1);</span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;;</span><br><span class="line">foo(); <span class="comment">// foo1</span></span><br></pre></td></tr></table></figure>
<p>输出结果是foo1。这里我在最内层的<code>console.log</code>中打印a1，此时，因为最内层的作用域中没有a1的相关定义，所以会往上层作用域搜索，得到a1=’foo1’。这里实际上有一个嵌套的作用域关系。</p>
<h2 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h2><p>这里还有一点需要注意，就是函数作用的嵌套关系是在定义时就会确定的，而非调用的时候。也即js的作用域是<strong>静态作用域</strong>，好像又叫<strong>词法作用域</strong>，因为<strong>在代码做语法分析时就确定下来了</strong>。看下面的这个例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a1);</span><br><span class="line">&#125;;</span><br><span class="line">foo1(); <span class="comment">// global</span></span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="string">'locale'</span>;</span><br><span class="line">    foo1();</span><br><span class="line">&#125;;</span><br><span class="line">foo2(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>示例的输出结果都将会是<code>global</code>。<code>foo1()</code>的执行结果为<code>global</code>不需要太多的解释，很容易明白。</p>
<p>因为<code>foo2</code>在执行时，调用<code>foo1</code>，<code>foo1</code>方法会从他自己的作用域开始搜索变量<code>a1</code>，最终在其父级作用域中找到<code>a1</code>，即<code>a1 = &#39;global&#39;</code>。由此可以看出，<code>foo2</code>内部的<code>foo1</code>在执行时并没有去拿<code>foo2</code>作用域中的变量<code>a1</code>。</p>
<p>以说<strong>作用域的嵌套关系并不是在执行时确定的，而是在定义时就确定好了的！</strong></p>
<h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>最后提一下全局作用域。通过字面的意思就能知道，全局作用域中的变量也好，属性也好，在任何函数中都能直接访问。</p>
<p>其中有一点需要注意，在任何地方没有通过var关键字声明的变量都是定义在全局变量中。其实，在模块化编程中，应该尽量避免使用全局变量，声明变量时，无论如何都应该避免<strong>不</strong>使用var关键字。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是函数式编程语言的一大语言特性。w3c上关于闭包的严格定义如下：<strong>由函数(环境)及其封闭的自由变量组成的集合体</strong>。这句话比较晦涩难懂，反正刚开始我是没看懂。下面通过一些例子来说明。</p>
<h2 id="闭包解释"><a href="#闭包解释" class="headerlink" title="闭包解释"></a>闭包解释</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> counter = closure();</span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(counter()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>最后的结果是1,2,3。</p>
<p>这个demo中，<code>closure</code>是一个函数(其实他相当于一个类的构造函数)，并且返回一个函数(这个<em>被返回的函数</em>加上<em>其定义环境</em>通俗上被称为<strong>闭包</strong>)。<br>在返回的函数中，引用了外部的<code>count</code>变量。在<code>var counter = closure();</code>这句代码之后，<code>counter</code>实际上就是一个函数，这样每次在<code>counter()</code>时，先将count自增然后打印出来。<br>这里<code>counter</code>的函数内部并没有关于<code>count</code>的定义，所以在执行时会往上层作用域搜索，而他的上层作用域是<code>closure</code>函数，而不是<code>counter()</code>执行时所在的上层作用域。</p>
<p>为什么它的上层作用域是<code>closure</code>函数呢？因为，</p>
<ul>
<li>第一，这是在定义的时候就已经确定好的函数作用域嵌套关系，</li>
<li>更重要的是第二点，闭包的返回不但有函数而且还包含定义函数的上下文环境。这里上下文环境就是<code>closure</code>函数的内部作用域，所以能够拿到<code>closure</code>函数中的<code>count</code>变量。</li>
</ul>
<p>从这里可以看出，闭包会造成对原作用域和其上层作用域的<strong>持续引用</strong>。在这里，<code>count</code>变量持续被引用，其所占用的内存就不会被释放掉。</p>
<p>在看下面的这个例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closure = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> counter1 = closure();</span><br><span class="line"><span class="keyword">var</span> counter2 = closure();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(counter2()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(counter1()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，生成的闭包实例是各自独立的，他们内部引用的<code>count</code>变量分别属于各自不同的运行环境。<br>我们可以这样理解，在闭包生成时，将原上下文环境做了一份拷贝副本，这样不同的闭包实例就有自己独立的运行环境了。</p>
<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><p>闭包目前来说有两大用处，</p>
<ul>
<li>第一是嵌套的回调函数</li>
<li>第二是隐藏对象的部分细节</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#id0'</span>).animate(&#123;</span><br><span class="line">    left: <span class="string">'+50px'</span></span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#id1'</span>).animate(&#123;</span><br><span class="line">        left: <span class="string">'+50px'</span></span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#id2'</span>).animate(&#123;</span><br><span class="line">            left: <span class="string">'+50px'</span></span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'done'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Javascript的对象没有私有成员的概念。一般的编码规范中会要求类似<code>_privateProp</code>的形式来定义私有属性。但是这是一个非正式的约定，而且<code>_privateProp</code>仍然能够被访问到。</p>
<p>我们可以通过闭包来实现私有成员，如下，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="function"><span class="keyword">function</span>(<span class="params">yourName, yourAge</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name, age;</span><br><span class="line"></span><br><span class="line">    name = yourName || <span class="string">''</span>;</span><br><span class="line">    age = yourAge || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;,</span><br><span class="line">        getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;,</span><br><span class="line">        setName: <span class="function"><span class="keyword">function</span>(<span class="params">yourName</span>) </span>&#123;</span><br><span class="line">            name = yourName;</span><br><span class="line">        &#125;,</span><br><span class="line">        setAge: <span class="function"><span class="keyword">function</span>(<span class="params">yourAge</span>) </span>&#123;</span><br><span class="line">            age = yourAge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mamamiya = student(<span class="string">'mamamiya'</span>, <span class="number">23</span>);</span><br><span class="line">mamamiya.getName();</span><br><span class="line">mamamiya.getAge();</span><br></pre></td></tr></table></figure>
<p>这里我封装了一个<code>student</code>类，并设置了两个属性<code>name</code>，<code>age</code>。这两个属性除了通过<code>student</code>对象的访问器方法访问之外，绝无其他的方法能够访问到。这里就实现了对部分属性的隐藏。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>Javascript的对象是基于原型的，和其他的一些面向对象语言有一些区别。</p>
<h2 id="创建和访问"><a href="#创建和访问" class="headerlink" title="创建和访问"></a>创建和访问</h2><p>我们可以通过如下的这种形式来创建一个js对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="string">'a'</span>: <span class="string">'baz'</span>,</span><br><span class="line">    <span class="string">'b'</span>: <span class="string">'foz'</span>,</span><br><span class="line">    <span class="string">'c'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello js'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们还可以通过构造函数来创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">name, uri</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.uri = uri;</span><br><span class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mamamiya = <span class="keyword">new</span> user(<span class="string">'mamamiya'</span>, <span class="string">'http://blog.gejiawen.com'</span>);</span><br><span class="line">mamamiya.show();</span><br></pre></td></tr></table></figure>
<p>Javascript中上下文对象就是<code>this</code>，他表示被调用函数所处的环境。他的作用就是在一个函数内部引用调用它自己。</p>
<p>在Javascript中，任何函数都是被某个对象调用。</p>
<h2 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a><code>apply</code>和<code>call</code></h2><p>在Javascript中<code>apply</code>和<code>call</code>是两个神奇的方法，他们的作用是以不同的上下文环境来调用函数。通俗点就是说，<strong>一个对象可以调用另一个对象的方法</strong>。</p>
<p>看下面的例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">'mamamiya'</span>,</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' says '</span> + words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.show.call(foo, <span class="string">'hello'</span>); <span class="comment">// baz says hello</span></span><br></pre></td></tr></table></figure>
<p>这段代码的结果是<code>baz says hello</code>。这里通过<code>call</code>方法改变了<code>user.show</code>方法的上下文环境，<code>user.show</code>方法在执行时，内部的<code>this</code>指向的是<code>foo</code>对象。</p>
<h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a><code>bind</code>方法</h2><p>可以使用<code>bind</code>方法永久的改变函数的上下文。<code>bind</code>将会返回一个函数引用。</p>
<p>看下面的这个例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">'mamamiya'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.func = user.func;</span><br><span class="line">foo.func(); <span class="comment">//baz</span></span><br><span class="line"></span><br><span class="line">foo.func1 = user.func.bind(user);</span><br><span class="line">foo.func1(); <span class="comment">//mamamiya</span></span><br><span class="line"></span><br><span class="line">func = user.func.bind(foo);</span><br><span class="line">func(); <span class="comment">//baz</span></span><br><span class="line">    </span><br><span class="line">func2 = func;</span><br><span class="line">func2(); <span class="comment">//baz</span></span><br></pre></td></tr></table></figure>
<p>其实，<code>bind</code>还可以在绑定上下文时附带一些参数。</p>
<p>不过有时候，<code>bind</code>会有一些让人迷惑的地方，看下面这个例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">'mamamiya'</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'baz'</span></span><br><span class="line">&#125;;</span><br><span class="line">func  = user.func.bind(foo);</span><br><span class="line">func(); <span class="comment">//baz</span></span><br><span class="line">func2 = func.bind(user);</span><br><span class="line">func2(); <span class="comment">//baz</span></span><br></pre></td></tr></table></figure>
<p>这里为什么<code>func2</code>函数的输出结果仍然是<code>baz</code>呢？</p>
<p>也就是说，我企图将<code>func</code>的上下文环境还原到<code>user</code>上为什么没有起作用？</p>
<p>我们这样来看，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func = user.func.bind(foo) ≈ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.func.call(foo);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func2 = func.bind(user) = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.call(user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ok，现在可以看出来，<code>func2</code>中实际上是以<code>user</code>为<code>this</code>指针调用了<code>func</code>，但是在<code>func</code>中并没有使用<code>this</code>。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>通过构造函数和原型都能生成对象，但是两者之间有一些区别。看下面的这个列子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">this</span>.prop1 = <span class="string">'git'</span>;</span><br><span class="line">    <span class="keyword">this</span>.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a = <span class="string">''</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class.prototype.prop2 = <span class="string">'Mercurial'</span>;</span><br><span class="line"></span><br><span class="line">Class.prototype.func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class1 = <span class="keyword">new</span> Class();</span><br><span class="line"><span class="keyword">var</span> class2 = <span class="keyword">new</span> Class();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(class1.func1 === class2.func1); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(class1.func2 === class2.func2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>所以说，挂在<code>prototype</code>上的属性，会被不同的实例会共享。通过构造函数创建出来的属性，每一个实例都有一份独立的副本。</p>
<h2 id="原型及基于原型的面向对象"><a href="#原型及基于原型的面向对象" class="headerlink" title="原型及基于原型的面向对象"></a>原型及基于原型的面向对象</h2><p>那么，<strong>什么叫原型链？</strong></p>
<p>JavaScript中有两个特殊的对象：<code>Object</code>与<code>Function</code>，它们都是构造函数，用于生成对象。<br><code>Object.prototype</code>是所有对象的祖先，<code>Function.prototype</code>是所有函数的原型，包括构造函数。</p>
<p>我把JavaScript中的对象分为三类，</p>
<ul>
<li>一类是用户创建的对象，即一般意义上用<code>new</code>语句显式构造的对象</li>
<li>一类是构造函数对象，即普通的构造函数，通过<code>new</code>调用生成普通对象的函数</li>
<li>一类是原型对象，即构造函数<code>prototype</code>属性指向的对象</li>
</ul>
<p>这三类对象中每一种都有一个<code>__proto__</code>属性，<strong>它指向该对象的原型</strong>。任何对象沿着它开始遍历都可以追溯到<code>Object.prototype</code>。</p>
<p>构造函数对象有<code>prototype</code>属性，指向一个原型对象，通过该构造函数创建对象时，被创建对象的<code>__proto__</code>属性将会指向构造函数的<code>prototype</code>属性。原型对象有<code>constructor</code>属性，指向它对应的构造函数。</p>
<p>看下面的这个例子，帮助理解，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">'My Object'</span>;</span><br><span class="line">foo.prototype.name = <span class="string">'baz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> foo();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// My Object</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.name); <span class="comment">// baz</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.__proto__.name); <span class="comment">// My Object</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__.constructor.prototype.name); <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<p>在Javascript中，继承是依靠一套叫做原型链的机制实现的。<br>说的通俗一点就是，在继承的时候，将父类的实例对象直接赋值给子类的<code>prototype</code>对象，这样子类就拥有了父类的全部属性。子类还可以在自己的prototype对象上增加自己的特殊属性。</p>
<p>看下面的例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.color = <span class="string">"blue"</span>;</span><br><span class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</span><br></pre></td></tr></table></figure>
<h2 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h2><p>Javascript中所有的对象类型的变量都是指向对象的引用。所以在赋值和传递的实际上都是对象的引用。</p>
<p>在Javascript中，对象的复制分为<strong>浅拷贝</strong>和<strong>深拷贝</strong>。</p>
<p>下面的示例是浅拷贝，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.makeCopy = funciton() &#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        newObj[i] = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'mamamiya'</span>,</span><br><span class="line">    likes: [<span class="string">'js'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = obj.makeCopy();</span><br><span class="line">obj.likes.push(<span class="string">'python'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.likes); <span class="comment">// ['js', 'python']</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.likes); <span class="comment">// ['js', 'python']</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，浅拷贝只是复制了一些基本属性，但是对象类型的属性是被共享的。<code>obj.likes</code>和<code>newObj.likes</code>都指向同一个数组。</p>
<p>想要做深拷贝，并不是一件容易的事情，因为除了基本数据类型，还有多种不同的对象，对象内部还有复杂的结构，因此需要用递归的方式来实现。</p>
<p>看下面的例子，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.makeDeepCopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) === <span class="string">'object'</span> || <span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) === <span class="string">'function'</span>) &#123;</span><br><span class="line">            newObj[i] = <span class="keyword">this</span>[i].makeDeepCopy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newObj[i] = <span class="keyword">this</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.makeDeepCopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArray = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) === <span class="string">'object'</span> || <span class="keyword">typeof</span>(<span class="keyword">this</span>[i]) === <span class="string">'function'</span>) &#123;</span><br><span class="line">            newArray[i] = <span class="keyword">this</span>[i].makeDeepCopy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newArray[i] = <span class="keyword">this</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.makeDeepCopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> newFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        newFunc[i] = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'mamamiya'</span>,</span><br><span class="line">    likes: [<span class="string">'js'</span>],</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = obj.makeDeepCopy();</span><br><span class="line">newObj.likes.push(<span class="string">'python'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.likes); <span class="comment">// ['js']</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.likes); <span class="comment">// ['js', 'python']</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.show == obj.show); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的示例代码中很好的实现了对象，函数，数组在做深拷贝的逻辑。在一般情况下都是比较好用的。但是有一种情况下，这种方法却无能为力。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    ref: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    ref: obj1</span><br><span class="line">&#125;;</span><br><span class="line">obj1.ref = obj2;</span><br></pre></td></tr></table></figure>
<p>上面这段代码块的逻辑很简单，就是两个相互引用的对象。</p>
<p>当我们试图使用深拷贝来复制<code>obj1</code>和<code>obj2</code>中的任何一个时，问题就出现了。因为深拷贝的做法是遇到对象就进行递归复制，那么结果只能无限循环下去。</p>
<p>对于这种情况，简单的递归已经无法解决，必须设计一套图论算法，分析对象之间的依赖关系，建立一个拓扑结构图，然后分别依次复制每个顶点，并重新构建它们之间的依赖关系。这已经超出了这里的讨论范围，而且在实际的工程操作中 几乎不会遇到这种需求，所以我们就不继续讨论了。</p>


            <div class="post-info">
    <p class="eof">- EOF -</p>
    <p class="copyright">All rights reserved <a href="http://gejiawen.github.io/about">@gejiawen</a>.</p>
    <p class="link">本文链接：<a href="http://blog.gejiawen.com/2014/09/19/some-javascript-advanced-feature/">http://blog.gejiawen.com/2014/09/19/some-javascript-advanced-feature/</a></p>

    <div class="share">
    分享本页：
    
        <div class="bdsharebuttonbox"><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a><a href="#" class="bds_more" data-cmd="more"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

    
    
</div>

</div>


            
    <section class="comment">
    <div class="ds-thread" data-thread-key="some-javascript-advanced-feature" data-title="Javascript中几个高级语言特性" data-url="http://blog.gejiawen.com/2014/09/19/some-javascript-advanced-feature/" data-author-key="gejiawen"></div>
</section>


<script type="text/javascript">
var duoshuoQuery = {short_name:"gejiawen-blog"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>





        </div>
    </div>
</article>

    <footer id="footer">
        <div id="bottom-tip">
            蛋糕仙人 —— <small>技术人需要危机感</small>
        </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/gejiawen/hexadillax2" target="_blank">Hexadillax2</a> 主题</small><br />
        <!--<small>如果你访问github速度过慢，可移步本站的备份站点<a href="http://gejiawen.gitcafe.io">gejiawen.gitcafe.io</a></small><br />-->
        <small>&copy; 2017 <a href="http://blog.gejiawen.com" target="_blank">gejiawen</a>&nbsp;<a href="http://www.miitbeian.gov.cn/" target="_blank">皖ICP备16008778号</a></small>
    </footer>
    
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e4dd778a6204eb51e4f25460e37481ad";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script type="text/javascript" src="http://tajs.qq.com/stats?sId=58628762" charset="UTF-8"></script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-51347904-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

